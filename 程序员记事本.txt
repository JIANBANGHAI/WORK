	JDK目录：
		lib目录下存放得是库文件
		bin目录存放得是编译器解释器和工具

	基本类型：
		1:char：取值范围为0到65535
		2:String：2.1：是fanal的，在java中final修饰的类不能被继承，charAt返回的类型是char
			  2.2：String类中的equals覆盖了超类的equlas，比较的是内容，==比较的是内存地址
		3:Math.cile：返回大于或则等于指定表达式的最小整数Math.ceil(5.6) //6
							Math.ceil(-5.6) //-5
		4:abs：返回得是绝对值,支持int,float,long,double,short,byte

	二进制：
		1:八个二进制位等于 一个字节
		2:<^>属于二进制位运算符 代表异或的意思运算时两个二进制数对应位的数不同时结果为1  否则为0
		3:>>为有符号右移，>>>为无符号右移，<<为有符号左移，不存在无符号左移运算符。

	变量：
		局部变量必须初始化才能使用

 	常见修饰词：
		public	 公开的	所有类
		private	私有的	当前类/本类	同包类
		protected	受保护的	本类
		static：修饰的方法不需要针对某些对象进行操作，其运行的结果仅仅与输入，
		    的参数有关调用时直接用类名点引用，由于static在调用时没有当前对象
		    this，因此在static方法中不能对非static成员（当前对象的属性和行为）
		    进行访问，但是非static方法可以访问static成员

	循环三要素：	
		1：循环变量的初始化	int a；
		2：循环变量的条件	boolean（a）
		3：循环变量的改变	a++/a--

	方法的五要素：	
		1：修饰词
		2：返回值类型
		3：方法名
		4：参数列表

	java方法传递：
		1：基本数据类型传递的是值本身
		2：引用数据类型传递也引用的值，是对象的地址，而不是对象本身

	引用数据类型数组：
		1：所谓引用类型数组，是数组的元素不是基本类型，而是引用类型。引用类型数组的初始化和
		    基本类型数组的初始化方式一样，只不过元素是引用而已，但需要注意的是:基本类型数组元
		    素的默认初始值为具体值（0），而引用类型数组创建的默认值为null，不是创建元素的对象

	隐式类型转换：
		1：隐式类型转换规则是： [byte]→[short(char)]→[int]→[long]→[float]→[double]

	方法的构造：
	  	1：子类的构造方法中必须通过super关键字调用父类的构造方法这样可以妥善的处初始化继承
	      	      自父类的成员变量，如果子类的构造方法中没有调用父类的构造方法，java会自动加入对
	       	      父类无参构造方法的使用（如果父类没有无参的构造方法，会编译错误）。

	方法的重载：
		1：在java语言中。允许【多个方法的名称相同但参数列表不同称之为重载】，与返回类型无关
		2：重载：发生在同一类中方法名相同 参数列表不同，方法体不同
		3：子类重写父类的方法如果是基本类型，要求相同


	方法的重写：
		1：子类可以重写（覆盖）继承自父类的方法，【方法名/参数列表与父类同】；子类利
		      用重写修改父类的方法,当子类对象的重写方法被调用时（无论是通过子类的引用调用
		      还是通过父类的引用调用），运行的是子类的重写修改后的版本
		2：重写： （发生在父子类中，方法名相同。参数列表相同，方法体不同运行期绑定）
		3：方法重写返回值类型如果是基本类型应与父类的一致

	静态常量/方法/类：
		1：final关键字修饰的类不可以被继承
		2：final关键字修饰的方法不可以在子类中被重写
		静态方法可以直接调用使用其外部的数据
		3：final关键字修饰成员变量，意为初始化并且赋值就不能被修改


	内存管理：
		1：方法区里用于保存类的各种信息（静态变量和静态方法）
		2：栈中用于存放程序运行过程当中·所有的局部变量（方法和参数）
		3：堆中一般用于储存使用new关键字创建的对象（成员变量）
		！类属于java语言中引用类型的一种，不属于JVM的内存结构

	成员内部类：
		1：一般情况下，内部类对象会在其所在的外部类对象中创建（构造方法/其他方法）；
		内部类对象中会有一个隐式的引用指向创建她的外部类
		对象。成员内部类，必须使用"外部类的实例.new"来创建对象



	常见面试题：
	问：你对面向对象的理解是什么：
	答：面向对象指的是，以对象为核心来思考，解决问题，主要是有三大特征
	    封装：
		1类：封装的是对象的属性和行为
		2方法：封装的是对象的业务逻辑功能实现
		3访问控制修饰符：封装具体的访问权限
	    继承：
		1作用：代码的复用
		2超类：所有派生类所共有的属性和行为
		3派生类：派生类所有的特性和行为
		4接口：部分派生类所共有的属性和行为
		5单一继承，多接口实现，具有传递性
	    多态：
		1意义:	行为多态(所有的抽象方法都是多态)
		        对象多态(所有的对象都是多态)
		2向上造型，强制性转换，instanceof判断
		3多态的表现形式：
			1：行为多态：因方法的重写而多态
			2：对象多态：因向上造型而多态  
	接口：
		1常量
		接口中不能有private方法，java中支持单一继承，修饰接口是可以public和默认的，接口里的属性都是常量。
		2抽象方法
		3在java8之前，接口中只能定义常量和抽象方法。
		抽象方法不能写大括号，abstract只能	修饰方法和类，不能修饰属性
		抽象方法不可以是静态的，不可以有方法体，不可以在普通类中定义，可以在接口中和抽象类中定义
		
	异常：
		1：IOException：所有的文件父类异常
		2：当程序满足某种特定的条件，可以使用throw具体的异常对象的方式抛出该异常对象
		3：为了保存资源释放，会将资源释放在finally语句块中

	线程：
		1：start和run方法的区别
			1.1：start方法 用 start方法来启动线程，是真正实现了多线程， 通过调用Thread类的start()方法来
			   启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行
		 	   run()方法。但要注意的是，此时无需等待run()方法执行完毕，即可继续执行下面的代码。所以run()方法并没有实现多线程。
			1.2：run方法 run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个
		 	   线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码。
		2：线程的描述:
			线程对象可以继承Thread和Runnable ，启动线程需要调用start()方法，一个进程可以包含多个线程
		3：sleep：让当前线程暂停指定时间；stop：这个方法将终止所有未结束的方法，包括run方法；wait：让当前线程睡觉，醒了接着干
		ArrayList和HashMap都是非线程安全；Vector和HashTbale都是线程安全的

	集合：
		集合类存放的都是对象的引用，而非对象本身，出于表达上的便利，我们称集合中的对象就是指集合中对象的引用（reference)。
		集合类型主要有3种：set(集）、list(列表）和map(映射)。

	反射：
		反射概念：JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它
		的任意一个方法和属性(也就是说包括private所修饰的)；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
	线程池：
		线程池：一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。

	StringBuffer及StringBuilder的异同：
		StringBuilder：线程非安全的StringBuffer：线程安全的当我们在字符串缓冲去被多个线程使用是，JVM不能保证StringBuilder的操作是安全的，虽然它的速度最快，
		但是可以保证StringBuffer是可以正确操作的。当然大多数情况下就是我们是在单线程下进行的操作，所以大多数情况下是建议用StringBuilder而不用StringBuffer的，就是速度的原因。